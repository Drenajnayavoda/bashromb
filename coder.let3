#!/bin/bash

#сначала делаем строку, разкладываем наши входные данные на отдельные числа с помощью параметра IFS и записываем в строку 

declare -a str

while IFS="" read -r -n 1 x; do
  str+=("$x")
done <<< $1

#в моей программе чтобы закодиравать числа надо после числа написать code чтобы кодировать, а чтобы декодировать надо после входных данных написать decode
#первая часть программы кодирует числа 

if [ $2 = "code" ]; then
echo "кодирование"
    for (( i=0; $i < ${#str[@]}; i++ )); do #создаем цикл, который берет из нашей строки по числу и с помощью специального bc калькулятора, который
      result=$(echo "obase=2; ${str[$i]}" | bc) # на ыход принимает десятичные числа а на выходе имеем двоичные 
      k=$((${#result} - 1))
        for (( j=0; j < k; j++ )); do  #затем создаем еще один цикл который выводит нужные нули
          echo -ne "0"   
        done
      echo -ne "1"$result #выводим единицу плюс наше двоичное число
    done
  echo

#вторая часть декодирует числа

elif [ $2 = "decode" ]; then
 mount=0 #вспомогательная переменная для подсчета символов
  bool=0 #вспомогательная переменная для правильного считывания, это необходимо из за того, что двоичное число может состоять из нескольких символов
  echo "декодирование:"
  for i in ${str[@]}; do
    if ((bool)); then      #если бул равен 1 считываем число, если нулю то считываем колличество символов
      if (($mount != 0)); then #обнуляем счетчик
        str2=$str2$i
        mount=$(($mount - 1))
      fi
        if (($mount == 0)); then
        bool=0
        num=$(($str2))
        str2=""
        result=$result$(echo "ibase=2;$num" | bc) #считываем число в result с помщью bc
      fi
      else
        mount=$(($mount + 1)) #прибавляем 1 к счетчику, если наше следующее число это 1, ставим бул 1
          if (($i == "1")); then
          bool=1
        fi
      fi
    done
    for i in ${result[@]}; do #выводим результат
      echo -n $i
    done

else
echo "ERROR: напишите опцию ПОСЛЕ числа (code/decode)!"
exit 1
fi

echo

exit 0
